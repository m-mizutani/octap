package usecase

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"

	"github.com/m-mizutani/goerr/v2"
	"github.com/m-mizutani/octap/pkg/domain/interfaces"
	"github.com/m-mizutani/octap/pkg/domain/model"
	"gopkg.in/yaml.v3"
)

type configService struct {
	defaultPath string
}

// NewConfigService creates a new ConfigService instance
func NewConfigService() interfaces.ConfigService {
	var defaultPath string
	if homeDir, err := os.UserHomeDir(); err == nil {
		defaultPath = filepath.Join(homeDir, ".config", "octap", "config.yml")
	}
	// If homeDir cannot be determined, defaultPath remains empty string
	// LoadDefault will handle empty defaultPath appropriately
	return &configService{
		defaultPath: defaultPath,
	}
}

// Load loads configuration from the specified path
func (c *configService) Load(path string) (*model.Config, error) {
	expandedPath := expandPath(path)

	data, err := os.ReadFile(expandedPath) // #nosec G304 - path is from user config
	if err != nil {
		if os.IsNotExist(err) {
			// Return empty config if file doesn't exist
			return &model.Config{}, nil
		}
		return nil, goerr.Wrap(err, "failed to read config file")
	}

	var config model.Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, goerr.Wrap(err, "failed to parse config file")
	}

	return &config, nil
}

// LoadDefault loads configuration from the default path
func (c *configService) LoadDefault() (*model.Config, error) {
	if c.defaultPath == "" {
		// No default path available (e.g., home directory could not be determined)
		// Return empty config without error
		return &model.Config{}, nil
	}
	return c.Load(c.defaultPath)
}

// LoadFromDirectory loads configuration from a directory by looking for .octap.yml or .octap.yaml
func (c *configService) LoadFromDirectory(dir string) (*model.Config, error) {
	configPath := c.findConfigInDirectory(dir)
	if configPath == "" {
		// No config file found in directory
		return &model.Config{}, nil
	}
	return c.Load(configPath)
}

// findConfigInDirectory looks for .octap.yml or .octap.yaml in the specified directory
// Returns the path of the first config file found, or empty string if none found
// Priority: .octap.yml > .octap.yaml
func (c *configService) findConfigInDirectory(dir string) string {
	candidates := []string{
		filepath.Join(dir, ".octap.yml"),
		filepath.Join(dir, ".octap.yaml"),
	}

	for _, candidate := range candidates {
		if _, err := os.Stat(candidate); err == nil {
			return candidate
		}
	}

	return ""
}

// GetDefaultPath returns the default configuration file path
func (c *configService) GetDefaultPath() string {
	return c.defaultPath
}

// GenerateTemplate generates a configuration template
func (c *configService) GenerateTemplate() string {
	successSoundPath, errorSoundPath := getDefaultSoundPaths()
	completeSuccessSoundPath, completeFailureSoundPath := getCompleteSoundPaths()

	return fmt.Sprintf(`# octap configuration file
# Generated by: octap config init

# Hook definitions
# Available events:
#   - check_success: Triggered when a workflow check succeeds
#   - check_failure: Triggered when a workflow check fails
#   - complete_success: Triggered when all workflows complete successfully
#   - complete_failure: Triggered when any workflow fails

hooks:
  # Individual workflow events
  check_success:
    # Play sound on success
    - type: sound
      path: %s
    
  check_failure:
    # Play sound on failure
    - type: sound
      path: %s
  
  # All workflows completion events
  complete_success:
    # Play sound when all workflows complete successfully
    - type: sound
      path: %s
  
  complete_failure:
    # Play different sound when workflows fail
    - type: sound
      path: %s
`, successSoundPath, errorSoundPath, completeSuccessSoundPath, completeFailureSoundPath)
}

// getDefaultSoundPaths returns OS-specific default sound file paths
func getDefaultSoundPaths() (successPath, errorPath string) {
	switch runtime.GOOS {
	case "darwin":
		return "/System/Library/Sounds/Glass.aiff", "/System/Library/Sounds/Basso.aiff"
	case "linux":
		return "/usr/share/sounds/freedesktop/stereo/complete.oga", "/usr/share/sounds/freedesktop/stereo/dialog-error.oga"
	case "windows":
		return "C:\\Windows\\Media\\chimes.wav", "C:\\Windows\\Media\\chord.wav"
	default:
		return "~/sounds/success.mp3", "~/sounds/error.mp3"
	}
}

// getCompleteSoundPaths returns OS-specific sound file paths for completion events
func getCompleteSoundPaths() (successPath, errorPath string) {
	switch runtime.GOOS {
	case "darwin":
		return "/System/Library/Sounds/Ping.aiff", "/System/Library/Sounds/Funk.aiff"
	case "linux":
		return "/usr/share/sounds/freedesktop/stereo/bell.oga", "/usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga"
	case "windows":
		return "C:\\Windows\\Media\\ding.wav", "C:\\Windows\\Media\\Windows Critical Stop.wav"
	default:
		return "~/sounds/complete-success.mp3", "~/sounds/complete-error.mp3"
	}
}

// SaveTemplate saves the configuration template to the specified path
func (c *configService) SaveTemplate(path string, force bool) error {
	expandedPath := expandPath(path)

	// Check if file exists
	if _, err := os.Stat(expandedPath); err == nil && !force {
		return goerr.New("config file already exists, use --force to overwrite")
	}

	// Create directory if it doesn't exist
	dir := filepath.Dir(expandedPath)
	if err := os.MkdirAll(dir, 0750); err != nil { // #nosec G301
		return goerr.Wrap(err, "failed to create directory")
	}

	// Write template
	template := c.GenerateTemplate()
	if err := os.WriteFile(expandedPath, []byte(template), 0600); err != nil { // #nosec G306
		return goerr.Wrap(err, "failed to write config file")
	}

	fmt.Printf("Configuration template created at: %s\n", expandedPath)
	return nil
}

// expandPath expands ~ to home directory
func expandPath(path string) string {
	if path == "" {
		return path
	}

	if path[0] == '~' {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			// If home directory cannot be determined, return path as-is
			// This will likely cause an error later, but that's better than silently using wrong path
			return path
		}
		return filepath.Join(homeDir, path[1:])
	}

	return path
}
